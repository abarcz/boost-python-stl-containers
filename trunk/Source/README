Dziala Makefile! :)

W pliku Python_test.py proste testy obejmujace:
	- map_int_string
	- vector_int
	- set_int
	- vector_double
	- vector_string
	- set_double
	- set_string

W pliku Python_test_vector.py testy jednostkowe dla vector<int>

W pliku Python_test_vector_foo.py testy jednostkowe dla vector<Foo> (uproszczone, bo Foo nie ma operatorow porownania)

W pliku Python_test_vector_foobar.py testy jednostkowe dla vector<Foobar>

W pliku Python_test_Python_test_py_list_to_vector.py testy działania konwertera pylist->vector dla int, double

W pliku Python_test_Python_test_py_dict_to_map.py testy działania konwertera pyDict->map

Sposob wrappowania przez uzytkownika dowolnej klasy Foo za pomoca naszych wrapperow:
- vector<Foo> : przed zaincludowaniem VectorWrapper_py.hpp musi pojawic sie:
	#define STL_TO_PYTHON_CONTAINERS_COMPARABLE - jesli Foo posiada operatory porownania
	#define STL_TO_PYTHON_CONTAINERS_PRINTABLE - jesli Foo moze byc wypisywane na cout

- map<stl_type, Foo> : przed zaincludowaniem MapWrapper_py.hpp musi pojawic sie:
	#define STL_TO_PYTHON_CONTAINERS_PRINTABLE - jesli Foo moze byc wypisywane na cout
	mapa nie posiada metod wymagajacych operatorow porownania na Foo

- set<Foo> : przed zaincludowaniem SetWrapper_py.hpp musi pojawic sie:
	#define STL_TO_PYTHON_CONTAINERS_PRINTABLE - jesli Foo moze byc wypisywane na cout
	uzycie set'a na klasie nie posiadajacej operatora porownania mija sie z celem
	-> blad kompilacji	

Moduł TestModule: do wrappowania fcji i klas C++ potrzebnych do wykonania rozmaitych testow, m.in. konwerterow
Udostępnia pod Pythonem:
get_vector_sum_int/double(std::vector<T);	//zwraca sumę elementow wektora
Foo()						//prosta klasa, bez operatorow porownania i <<
vector_foo					//vector<Foo>
map_int_foo					//map<int, Foo>

Moduł TestModule2: j.w.
Udostępnia pod Pythonem:
Foobar()					//klasa Foo() + operatory porównania, bez <<
vector_foobar
map_int_foobar
set_foobar

TODO:

Dopisanie do klasy Foobar możliwości wypisywania jej na ekran (niekonieczne)		[Aleks/Michal]
Powazne testy jednostkowe 								[Michal]
Makefile/scons										[Michal]
Dodatkowe metody (umozliwienie tworzenia slice'ow) 					[Michal]
Uporzadkowanie kodu									[Aleks/Michal]
Dokumentacja										[Aleks/Michal]



Błędy niezależne(?) od nas:

W PyListToVector:
Przy konwersji Python::long -> C++::int występuje OverflowError - niby powinien dać się przechwycić, ale koniec końców wyskakuje nie wiadomo skąd
jakiś czas później (garbage collector?)
Z tego względu pod embedded prawdopodobnie trzeba będzie zrezygnować z PyFinalize(), a pod interpreterem.. nie konwertować longów na int :]
